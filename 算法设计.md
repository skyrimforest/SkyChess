
# 🎯 国际象棋算法层 Prompt（Research-grade）

## 任务目标

请你设计并实现一个**研究级国际象棋算法层（Chess Algorithm Core）**，用于：

* 搜索算法研究（Minimax / Alpha-Beta / MCTS）
* 经典引擎集成（Stockfish）
* 强化学习 / 自博弈（Self-play）
* 未来接入 LLM Chess Agent

**该层不包含任何 UI、HTTP、前端或数据库逻辑**，仅关注**算法、状态、接口与可扩展性**。

---

## 1️⃣ 设计原则（必须遵守）

1. **算法与规则解耦**
2. **Agent ≠ Engine ≠ Game**
3. **接口稳定，可长期用于论文复现**
4. **支持多 Agent 同局对弈**
5. **尽量参考当前主流研究范式**

   * OpenAI Gym / PettingZoo
   * AlphaZero / MuZero 风格抽象
   * UCI Engine Adapter 思路

---

## 2️⃣ 目录结构要求

```text
algorithms_core/
├── game/
│   ├── chess_game.py
│   ├── game_state.py
│   └── types.py
│
├── agent/
│   ├── base.py
│   ├── random_agent.py
│   └── registry.py
│
├── engine/
│   ├── base.py
│   ├── minimax.py
│   ├── mcts.py
│   └── stockfish_engine.py
│
├── eval/
│   ├── base.py
│   └── material_eval.py
│
├── record/
│   └── game_record.py
│
└── README.md
```

---

## 3️⃣ Game / Environment 层设计

### 3.1 GameState（核心数据结构）

```python
@dataclass
class GameState:
    fen: str
    current_player: Color
    move_history: list[ChessMove]
    is_terminal: bool
    result: Optional[GameResult]
```

要求：

* FEN 作为**唯一真实状态**
* 不缓存搜索结果
* 可被序列化，用于数据集生成

---

### 3.2 ChessGame（环境抽象）

```python
class ChessGame:
    def reset(self) -> GameState
    def step(self, move: ChessMove) -> GameState
    def legal_moves(self) -> list[ChessMove]
    def clone(self) -> "ChessGame"
```

设计要求：

* `clone()` 用于搜索树展开
* 不包含任何 Agent 或 Engine 逻辑
* 可用于 Self-play

---

## 4️⃣ Agent 抽象（策略层）

```python
class ChessAgent(ABC):
    name: str

    def reset(self, color: Color): ...
    def act(self, state: GameState) -> ChessMove
```

约束：

* Agent 不关心 UI / API
* Agent 可内部调用 Engine
* Agent = 决策策略，不等于搜索算法

---

### 示例 Agent（必须提供）

* RandomAgent
* EngineBasedAgent（包装 Minimax / Stockfish）

---

## 5️⃣ Engine / Search 层（算法核心）

### 5.1 搜索引擎抽象

```python
class SearchEngine(ABC):
    def search(
        self,
        game: ChessGame,
        time_limit: float | None = None,
        depth_limit: int | None = None
    ) -> ChessMove
```

要求：

* SearchEngine **不持有 GameState**
* 通过 `clone()` 操作环境
* 便于替换搜索算法

---

### 5.2 必须实现的 Engine

#### ✅ Minimax（含 Alpha-Beta）

* 可配置深度
* 可注入 Evaluation Function

#### ✅ MCTS

* UCT
* 明确 Node / Tree 结构
* 为未来神经网络扩展预留接口

#### ✅ StockfishEngine（UCI Adapter）

* 使用子进程
* FEN 输入 / UCI 输出
* 不污染其他 Engine

---

## 6️⃣ Evaluation 抽象

```python
class Evaluator(ABC):
    def evaluate(self, state: GameState) -> float
```

要求：

* 与搜索算法解耦
* 提供至少一个：

  * Material-based Evaluation
* 未来可替换为 NN Eval

---

## 7️⃣ 多 Agent / 对弈支持

```python
class MatchRunner:
    def run(self, white: ChessAgent, black: ChessAgent) -> GameRecord
```

* 用于：

  * Self-play
  * 算法对比
  * Elo 评估（未来）

---

## 8️⃣ 研究友好性要求（非常重要）

必须保证：

* 算法不依赖全局变量
* 可复现实验（随机种子可控）
* 不写“魔法参数”

---

## 9️⃣ README 要求

README 中必须说明：

* 有什么需要下载的模型请在README中说明
* 核心抽象设计理念
* Agent / Engine / Game 的区别
* 如何新增一个算法
* 如何用于 RL / Self-play

---

## 10️⃣ 输出要求

请直接输出：

1. **完整 Python 代码**
2. 合理的 docstring
3. README.md

请不要输出任何前端或 API 代码。

